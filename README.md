# ATP-Cup

In cadrul Turneului International de Tenis ATP Cup, fiecare stat participant are un lot de jucatori. Acest lot urmeaza sa-si reprezinte tara intr-o succesiune de meciuri jucate contra membrilor celorlalte loturi. Se doreste realizarea unei solutii software care sa automatizeze desfasurarea turneului. Solutia simuleaza turneul de tenis, respectand cerintele date.

Proiectul se ruleaza cu ajutorul unui Makefile care prin functia build creeaza un executabil. Acesta este ulterior sters automat prin functia clean.

1. La prima cerinta am creat o lista dublu inlantuita cu santinele la final. Intotdeauna santinela->next va pointa catre root, iar      santinela->prev la ultimul element din lista, iar root->next la primul element si root->prev la santinela.
Am construit o functie de adaugare nod cu nod, iar pentru asta am folosit un for in main cu i de la 0 la nr de tari total -1.

2. La a doua cerinta am luat un vector in care am pus toate toate valorile date de media scorurilor personale ale jucatorilor fiecarei tari ramase in competitie. Am folosit o functie, care sa imi sorteze crescator acest vector. Cu alta functie am aflat numarul de tari care ar trebuie sa ramana in concurs(cel mai apropiat multiplu al lui 2). Datorita faptului ca stim cate tari au fost initial si cate tari ar trebui sa ramana, eliminam un nr de tari egal cu diferenta dintre acestea. Astfel mergem in vectorul sortat si eliminam cate o tara pana se ajunge la nr de tari cerut. Cum procedeul se reia pornind de la santinela, suntem siguri ca, in cazul in care doua sau mai multe tari au acelasi scor, se va elimina prima/primele gasita/gasite.

3. La a treia cerinta am creat o stiva in care am pus toate informatiile despre fiecare tara ramasa in lista intr-un nod nou. Am folosit doua auxiliare de tip Country in care am pus cate o pereche de tari, iar dupa ce am prelucrat informatiile, am pus urmatoarea pereche de tari, pana cand stiva initiala a devenit goala. Am creat o coada in care am pus meciurile dintre jucatorii celor doua tari, unul cate unul(cu ajutorul a doua for-uri, prin care ma asiguram ca fiecare jucator al primei tari va juca cu fiecare jucator al celei de-a doua tari), iar in fuctia deQueue(de scoatere din coada) am adaugat si afisarea in fisierul rezultate.out a meciurilor.
La inceputul functiei am luat 2 variabile care retineau scorul fiecarei echipe, iar dupa meci cea cu scorul mai mare mergea mai departe. Dupa fiecare meci, scorul se reseta.
Am creat, de asemenea si o functie, care verifica, in caz de egalitate de scoruri, care este jucatorul cu scorul personal mai mare, pentru ca echipa care il contine va merge mai departe.
Am creata o stiva WINNER care continea la sfarsitul fiecarei etape toti jucatorii care au avansat in runda urmatoare. Dupa aceasta toti jucatorii din stiva WINNER erau adaugati in stiva initiala.

4. La cea de-a patra cerinta m-am ajutat de functia de la exercitiul 3 pentru a reusi sa stochez corect scorurile finale ale jucatorilor care au fost minim semifinalisti (am folosit in functie o variabila care ma ajuta sa aflu in ce etapa a turneului suntem din cauza ca nu am reusit sa folosesc functia pow, desi am facut link-urile cu math.h adaugand -lm la gcc). Dupa ce am retinut toti jucatorii care au ajuns in semifinala, a trebuit sa elimin, in caz ca exista, unul dintre cei doi jucatori cu acelasi scor personal. Am creat o functie care ii compara pe cei doi jucatori (cu strcmp) si il lasa in vectorul de jucatori pe cel care avea numele mai mic dpdv lexicografic.
Ulterior, am creat un BST si am pus jucatorii in el in functie de scorurile lor personale. Cum functia inorder ne afisa jucatorii in ordine crescatoare, am adaptat algoritmul si am procesat mai intai subarborele drept (unde se aflau valori mai mari decat radacina), iar apoi subarborele stang (unde se aflau valori mai mici decat radacina), obtinand astfel o afisare in ordine descrescatoare dupa scorurile personale.

5. La ultima cerinta am extras cei doi jucatori si scorurile lor personale si am creat o functie care verifica, in primul rand, cu ajutorul a doua variabile numite OK1 si OK2 daca acestia se afla in BST.
In cazul in care acestia nu se afla, ni se va afisa un mesaj lamuritor, iar in cazul in care acestia se afla, am implementat doua functii de parcurgere in inordine (una pentru cazul in care scorul personal al primului jucator este mai mare decat cel al celui de-al doilea jucator, iar a doua pentru cazul invers) si verificarea fiecarui element daca se afla in intervalul deschis al celor doua valori de scoruri personale.   M-am folosit de o variabila initializata cu valoarea 0, care crestea cu cate o unitate in momentul in care gasea o valoare corespunzatoare.
